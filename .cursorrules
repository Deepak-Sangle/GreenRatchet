# GreenRatchet - Cursor AI Rules & Best Practices

## Project Overview

A production-credible Sustainability-Linked Loans (SLL) platform with automated ESG assurance for AI workloads. Built with Next.js 15, TypeScript, Prisma, and shadcn/ui.

---

## ‚ö†Ô∏è CRITICAL CODING RULES (MUST FOLLOW)

### 1. **DRY - Don't Repeat Yourself**

**Extract helper functions for ANY repeated logic (3+ lines repeated = refactor immediately).**

```tsx
// ‚ùå BAD - Repeated code
const serviceId1 = `${metric.serviceName}-${metric.region}-${metric.instanceType || "default"}`;
const serviceId2 = `${metric.serviceName}-${metric.region}-${metric.instanceType || "default"}`;

// ‚úÖ GOOD - Helper function
function generateServiceId(metric: ServiceMetrics) {
  return `${metric.serviceName}-${metric.region}-${metric.instanceType || "default"}`;
}
```

### 2. **Immutability - Never Mutate**

**Use immutable patterns. Never mutate objects/arrays directly.**

```tsx
// ‚ùå BAD - Mutation
existingMetrics.totalCost += metric.totalCost;
array.push(item);

// ‚úÖ GOOD - Immutable
const updated = {
  ...existingMetrics,
  totalCost: existingMetrics.totalCost + metric.totalCost,
};
const newArray = [...array, item];
```

### 3. **Strong Typing - No `any`, No Implicit Types**

**Every function parameter, return value, and variable must be explicitly typed.**

```tsx
// ‚ùå BAD
function process(data: any) { ... }
const result = await fetch(url);

// ‚úÖ GOOD
function process(data: MetricsData): ProcessedResult { ... }
const result: ApiResponse = await fetch(url);
```

### 4. **Use ts-pattern for Complex Conditionals**

**Replace nested if/else and switch with `match` from ts-pattern.**

```tsx
import { match } from "ts-pattern";

// ‚ùå BAD
if (metric.serviceName === "EC2") {
  // ...
} else if (metric.serviceName === "RDS") {
  // ...
} else if (metric.serviceName === "S3") {
  // ...
}

// ‚úÖ GOOD
match(metric.serviceName)
  .with("EC2", () => ({ instanceType: metric.instanceType }))
  .with("RDS", () => ({ dbClass: metric.dbInstanceClass }))
  .with("S3", () => ({}))
  .exhaustive();
```

### 5. **Helper Functions Everywhere**

**Every reusable piece of logic must be a named helper function with JSDoc.**

```tsx
// ‚úÖ GOOD - Small, focused helpers
/**
 * Calculates total network traffic from multiple metric arrays
 */
function calculateNetworkTotal(...metrics: MetricData[][]): number | undefined {
  const total = metrics.reduce(
    (sum, arr) => sum + arr.reduce((a, b) => a + b.value, 0),
    0
  );
  return total > 0 ? total : undefined;
}
```

---

## üìã General Guidelines

### Documentation Policy

**NEVER create `.md` documentation files after implementing a feature unless explicitly requested.**


## üé® UI/UX Standards

### Design System

- **Colors**: Use emerald/sage palette, HSL variables (`bg-primary`, `text-primary-foreground`)
- **Shadows**: `shadow-soft`, `shadow-soft-lg` (no hard shadows)
- **Transitions**: All interactive elements use `transition-all duration-200`
- **Spacing**: Cards=`p-6`, Default gap=`gap-4`, Sections=`gap-6`
- **Icons**: lucide-react only, `h-4 w-4` (buttons), `h-6 w-6` (large)
- **Typography**: `font-heading` for headings, `text-muted-foreground` for secondary text

### Component Patterns

```tsx
// Forms: Always use react-hook-form + Zod
const form = useForm<T>({ resolver: zodResolver(Schema) });

// Dialogs: Use shadcn Dialog with consistent error display
{
  error && (
    <div className="rounded-md bg-destructive/15 p-3 text-sm text-destructive">
      {error}
    </div>
  );
}

// Buttons: Include loading states and icons
<Button disabled={loading}>{loading ? "Loading..." : "Submit"}</Button>;

// Responsive: Mobile-first with sm: md: lg: breakpoints
className = "flex flex-col sm:flex-row";
```

---

## üèóÔ∏è Architecture & File Structure

### Directory Organization

```
app/
  actions/          # Server Actions (mutations)
  [route]/          # Route folders with page.tsx and layout.tsx
  api/              # API routes (use sparingly, prefer Server Actions)
  generated/        # Prisma Client & Zod schemas (auto-generated)
components/
  [feature]/        # Feature-specific components
  ui/               # shadcn/ui components (base layer)
  dashboard/        # Layout components (header, nav)
lib/
  services/         # Business logic, external integrations
  validations/      # Zod schemas for forms and server actions
  prisma.ts         # Prisma client singleton
  utils.ts          # Utility functions
prisma/
  schema.prisma     # Database schema
  migrations/       # Migration history
```

### Naming Conventions

- **Files**: kebab-case (`user-profile.tsx`, `kpi-calculator.ts`)
- **Components**: PascalCase (`UserProfile`, `KPICalculator`)
- **Functions**: camelCase (`createLoan`, `calculateKPI`)
- **Server Actions**: Suffix with `Action` (`createLoanAction`, `updateAvatarAction`)
- **Types**: PascalCase (`CreateLoanForm`, `KPIResult`)
- **Zod Schemas**: PascalCase with `Schema` suffix (`CreateLoanSchema`)

---

## üîß Backend Patterns

### Server Actions (7-Step Pattern)

```tsx
"use server";

export async function createResourceAction(data: FormData) {
  try {
    // 1. Auth check
    const session = await auth();
    if (!session?.user?.id) return { error: "Unauthorized" };

    // 2. Get user
    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      include: { organization: true },
    });

    // 3. Authorization
    if (!user || user.role !== "REQUIRED_ROLE") return { error: "Insufficient permissions" };

    // 4. Validate with Zod
    const validated = await ValidationSchema.parseAsync(data);

    // 5. Database operation
    const resource = await prisma.resource.create({ data: { ...validated, userId: user.id } });

    // 6. Audit log
    await prisma.auditLog.create({ data: { action: "RESOURCE_CREATED", ... } });

    // 7. Revalidate paths
    revalidatePath("/dashboard");

    return { success: true, data: resource };
  } catch (error) {
    return { error: error instanceof Error ? error.message : "Operation failed" };
  }
}
```

### Zod Schemas

```tsx
// Use generated schemas from Prisma
import { LoanSchema } from "@/app/generated/schemas/schemas";

// Form schema (dates as strings)
export const CreateLoanFormSchema = LoanSchema.omit({ id: true, ...timestamps }).extend({
  startDate: z.string().min(1),
  maturityDate: z.string().min(1),
}).refine(data => new Date(data.maturityDate) > new Date(data.startDate), {
  message: "Maturity must be after start",
  path: ["maturityDate"],
});

// Server schema (dates as Date objects)
export const CreateLoanSchema = LoanFormFields.extend({
  startDate: z.coerce.date(),
  maturityDate: z.coerce.date(),
}).refine(...);
```

### Prisma Patterns

```prisma
// Schema: SCREAMING_SNAKE_CASE enums, explicit relations, timestamps, cascade deletes
enum UserRole { BORROWER LENDER }
model Loan {
  borrowerOrg Organization @relation("BorrowerOrganization", fields: [borrowerOrgId], references: [id])
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  kpis        KPI[]        @relation(onDelete: Cascade)
}
```

```tsx
// Queries: Select only needed fields, use include for relations, use transactions
const user = await prisma.user.findUnique({
  where: { id },
  select: { id: true, name: true, email: true },
});

await prisma.$transaction([
  prisma.loan.update({ where: { id }, data: { ... } }),
  prisma.auditLog.create({ data: { ... } }),
]);
```

### Error Handling

```tsx
// Always return structured { success, data } or { error }
try {
  return { success: true, data: result };
} catch (error) {
  return { error: error instanceof Error ? error.message : "Operation failed" };
}
```

## üîê Security

```tsx
// Always check auth + authorization
const session = await auth();
if (!session?.user) return { error: "Unauthorized" };

const user = await prisma.user.findUnique({
  where: { id: session.user.id },
  include: { organization: true },
});
if (user.role !== "BORROWER") return { error: "Insufficient permissions" };
if (loan.borrowerOrgId !== user.organizationId)
  return { error: "Access denied" };

// ALWAYS validate with Zod before DB operations
const validated = await Schema.parseAsync(input);
```

---

## üéØ Code Standards

### TypeScript & Imports

```tsx
// Avoid `any`, use proper types, explicit when needed
const form = useForm<FormType>({ ... });
const name = user?.name ?? "Unknown"; // Optional chaining + nullish coalescing

// Import order: React -> Third-party -> Internal -> Types
import { useState } from "react";
import { useForm } from "react-hook-form";
import { Button } from "@/components/ui/button";
import type { CreateLoanForm } from "@/lib/validations/loan";
```

### Comments & Performance

```tsx
// JSDoc for complex functions only
/**
 * Calculates KPI results
 * @param kpiId - The KPI to calculate
 * @returns KPI result with status
 */

// Use Server Components by default, "use client" only when needed
// Memoize expensive computations: useMemo, useCallback
// Lazy load: dynamic(() => import("./chart"), { ssr: false })
```

---

## ‚úÖ Feature Implementation Checklist

### When Creating New Features

1. ‚úÖ **Extract helper functions** for any repeated logic (DRY principle)
2. ‚úÖ **Use immutable patterns** - never mutate variables
3. ‚úÖ **Strong typing** - explicit types for all functions
4. ‚úÖ **Use ts-pattern** for complex conditionals
5. ‚úÖ Start with Server Components, add "use client" only if needed
6. ‚úÖ Create Zod schema in `lib/validations/`
7. ‚úÖ Create Server Action in `app/actions/` (7-step pattern)
8. ‚úÖ Add audit logging for important actions
9. ‚úÖ Revalidate affected paths
10. ‚ùå **DO NOT create `.md` documentation files**

### Code Review Checklist

- [ ] **No repeated code** - extracted to helper functions
- [ ] **No mutations** - immutable patterns used
- [ ] **Strongly typed** - no `any`, explicit types
- [ ] **ts-pattern** used for complex conditionals
- [ ] Validates all inputs with Zod
- [ ] Checks authentication and authorization
- [ ] Proper error handling (`{ success, data }` or `{ error }`)
- [ ] Follows design system
- [ ] Includes loading states
- [ ] Responsive and accessible

---

**Remember**: Follow established patterns. The most important rules are at the top (DRY, Immutability, Strong Typing, ts-pattern, Helper Functions).
