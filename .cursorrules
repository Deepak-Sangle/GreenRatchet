# GreenRatchet - Cursor AI Rules & Best Practices

## Project Overview

A production-credible Sustainability-Linked Loans (SLL) platform with automated ESG assurance for AI workloads. Built with Next.js 15, TypeScript, Prisma, and shadcn/ui.

---

## üé® UI/UX Design System

### Core Design Principles

1. **Refined Green Palette**: Use the emerald/sage color scheme consistently
2. **Subtle Depth**: Prefer soft shadows (`shadow-soft`, `shadow-soft-lg`) over hard shadows
3. **Smooth Transitions**: All interactive elements should have `transition-all duration-200`
4. **Modern Spacing**: Use consistent spacing (p-6 for cards, gap-4 for flex containers)
5. **Accessibility First**: Always include proper ARIA labels and keyboard navigation

### Component Standards

#### Buttons

```tsx
// Use predefined variants: default, destructive, outline, secondary, ghost, link
// Include icons with lucide-react, always with consistent sizing (h-4 w-4)
<Button variant="outline" size="sm">
  <Icon className="mr-2 h-4 w-4" />
  Button Text
</Button>

// Disabled states should be handled automatically
<Button disabled={loading}>
  {loading ? "Loading..." : "Submit"}
</Button>

// Active scaling on click (built into buttonVariants)
// Use `active:scale-[0.98]` for tactile feedback
```

#### Cards

```tsx
// Always use Card components with consistent structure
<Card className="float-card">
  {" "}
  {/* float-card adds hover effect */}
  <CardHeader>
    <CardTitle>Title Here</CardTitle>
    <CardDescription>Description with text-muted-foreground</CardDescription>
  </CardHeader>
  <CardContent>{/* Content */}</CardContent>
  <CardFooter>{/* Actions */}</CardFooter>
</Card>

// Cards should use rounded-xl borders
// Shadow system: shadow-soft for base, shadow-soft-lg for hover/elevated
```

#### Dialogs

```tsx
// Consistent dialog pattern across the app
const [open, setOpen] = useState(false);

<Dialog open={open} onOpenChange={setOpen}>
  <DialogTrigger asChild>
    <Button variant="outline">
      <Icon className="mr-2 h-4 w-4" />
      Action
    </Button>
  </DialogTrigger>
  <DialogContent className="sm:max-w-md">
    <DialogHeader>
      <DialogTitle>Clear Title</DialogTitle>
      <DialogDescription>
        Helpful description of what this dialog does
      </DialogDescription>
    </DialogHeader>

    {/* Error messages with consistent styling */}
    {error && (
      <div className="rounded-md bg-destructive/15 p-3 text-sm text-destructive">
        {error}
      </div>
    )}

    {/* Form content */}

    <DialogFooter className="flex gap-2 sm:gap-0">
      <Button variant="outline" onClick={() => setOpen(false)}>
        Cancel
      </Button>
      <Button type="submit" disabled={loading}>
        {loading ? "Processing..." : "Confirm"}
      </Button>
    </DialogFooter>
  </DialogContent>
</Dialog>;
```

#### Forms

```tsx
// Always use react-hook-form with zod validation
const form = useForm<FormType>({
  resolver: zodResolver(FormSchema),
  defaultValues: {
    // Define all fields with defaults
  },
});

// Standard form field pattern
<Form {...form}>
  <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
    <FormField
      control={form.control}
      name="fieldName"
      render={({ field }) => (
        <FormItem>
          <FormLabel>Field Label</FormLabel>
          <FormControl>
            <Input placeholder="Placeholder text" {...field} />
          </FormControl>
          <FormDescription>Optional helpful text</FormDescription>
          <FormMessage /> {/* Automatic error display */}
        </FormItem>
      )}
    />
  </form>
</Form>;
```

#### Typography

```tsx
// Headings use font-heading with tracking-tight
<h1 className="text-3xl font-heading font-bold tracking-tight">
  Main Heading
</h1>

// Use semantic text sizing
text-xs   (11px) - Helper text, captions
text-sm   (14px) - Body text, descriptions
text-base (16px) - Default body
text-lg   (18px) - Emphasized text
text-xl   (20px) - Card titles
text-2xl  (24px) - Section headings
text-3xl  (30px) - Page headings

// Muted text for secondary information
<p className="text-sm text-muted-foreground">Secondary info</p>
```

#### Spacing & Layout

```tsx
// Consistent padding/margin scale
gap-2  (0.5rem) - Tight grouping
gap-3  (0.75rem) - Related items
gap-4  (1rem)   - Default spacing
gap-6  (1.5rem) - Section spacing
gap-8  (2rem)   - Major sections

// Card padding is always p-6
// Use pt-0 for CardContent to avoid double padding with CardHeader

// Max-width containers
<div className="mx-auto max-w-7xl"> {/* Dashboard pages */}
<div className="sm:max-w-md"> {/* Dialogs */}
```

#### Interactive States

```tsx
// Hover states with smooth transitions
className="transition-all duration-200 hover:scale-105"
className="hover:bg-accent/60 hover:text-accent-foreground"

// Focus states (use focus-ring utility or built-in focus-visible)
className="focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring"

// Disabled states (automatic with shadcn components)
disabled={isLoading || !isValid}

// Group hover patterns for complex interactions
<div className="group">
  <div className="group-hover:opacity-100 transition-opacity" />
</div>
```

#### Colors & Gradients

```tsx
// Use HSL color variables consistently
(bg - primary, text - primary - foreground);
(bg - secondary, text - secondary - foreground);
(bg - accent, text - accent - foreground);
(bg - destructive, text - destructive - foreground);
(bg - muted, text - muted - foreground);

// Gradients (predefined in tailwind config)
className = "bg-gradient-to-br from-primary/20 to-accent";
className = "bg-gradient-primary"; // For special emphasis
className = "bg-mesh"; // For page backgrounds

// Opacity modifiers for subtle effects
(bg - primary / 10, bg - accent / 20, border - border / 50);
```

#### Icons

```tsx
// Use lucide-react exclusively
import { Icon } from "lucide-react";

// Standard sizing
className="h-4 w-4" // Default for buttons, inline
className="h-5 w-5" // Slightly larger emphasis
className="h-6 w-6" // Large icons
className="h-10 w-10" // Avatar size

// Always pair with proper spacing
<Icon className="mr-2 h-4 w-4" /> // Before text
<Icon className="ml-2 h-4 w-4" /> // After text
```

### Responsive Design

```tsx
// Mobile-first approach, use sm: md: lg: xl: breakpoints
className = "flex flex-col sm:flex-row";
className = "hidden sm:block"; // Hide on mobile
className = "text-sm sm:text-base"; // Responsive typography

// Navigation and complex layouts
className = "flex flex-1 overflow-hidden"; // Container
className = "flex-1 overflow-y-auto scrollbar-thin"; // Scrollable content
```

---

## üèóÔ∏è Architecture & File Structure

### Directory Organization

```
app/
  actions/          # Server Actions (mutations)
  [route]/          # Route folders with page.tsx and layout.tsx
  api/              # API routes (use sparingly, prefer Server Actions)
  generated/        # Prisma Client & Zod schemas (auto-generated)
components/
  [feature]/        # Feature-specific components
  ui/               # shadcn/ui components (base layer)
  dashboard/        # Layout components (header, nav)
lib/
  services/         # Business logic, external integrations
  validations/      # Zod schemas for forms and server actions
  prisma.ts         # Prisma client singleton
  utils.ts          # Utility functions
prisma/
  schema.prisma     # Database schema
  migrations/       # Migration history
```

### Naming Conventions

- **Files**: kebab-case (`user-profile.tsx`, `kpi-calculator.ts`)
- **Components**: PascalCase (`UserProfile`, `KPICalculator`)
- **Functions**: camelCase (`createLoan`, `calculateKPI`)
- **Server Actions**: Suffix with `Action` (`createLoanAction`, `updateAvatarAction`)
- **Types**: PascalCase (`CreateLoanForm`, `KPIResult`)
- **Zod Schemas**: PascalCase with `Schema` suffix (`CreateLoanSchema`)

---

## üîß Backend Best Practices

### Server Actions Pattern

```tsx
"use server";

import { auth } from "@/auth";
import { prisma } from "@/lib/prisma";
import { revalidatePath } from "next/cache";

// 1. Always validate authentication
// 2. Validate with Zod schema
// 3. Check authorization (role, ownership)
// 4. Perform operation with Prisma
// 5. Create audit log
// 6. Revalidate affected paths
// 7. Return { success: true, data } or { error: string }

export async function createResourceAction(data: FormData) {
  try {
    // 1. Auth check
    const session = await auth();
    if (!session?.user?.id) {
      return { error: "Unauthorized" };
    }

    // 2. Get user with necessary relations
    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      include: { organization: true },
    });

    // 3. Authorization check
    if (!user || user.role !== "REQUIRED_ROLE") {
      return { error: "Insufficient permissions" };
    }

    // 4. Validate input
    const validated = await ValidationSchema.parseAsync(data);

    // 5. Database operation
    const resource = await prisma.resource.create({
      data: {
        ...validated,
        userId: user.id,
      },
    });

    // 6. Audit log (for important actions)
    await prisma.auditLog.create({
      data: {
        action: "RESOURCE_CREATED",
        entity: "RESOURCE",
        entityId: resource.id,
        details: JSON.stringify({ name: resource.name }),
        userId: user.id,
      },
    });

    // 7. Revalidate paths
    revalidatePath("/dashboard");
    revalidatePath("/resources");

    return { success: true, data: resource };
  } catch (error) {
    console.error("Action error:", error);
    return {
      error: error instanceof Error ? error.message : "Operation failed",
    };
  }
}
```

### Zod Schema Patterns

#### Generated Schemas (from Prisma)

```tsx
// Import generated schemas from app/generated/schemas/schemas.ts
import { UserSchema, LoanSchema } from "@/app/generated/schemas/schemas";

// NEVER modify generated schemas directly
// Create derivative schemas in lib/validations/
```

#### Form Schemas (User Input)

```tsx
// lib/validations/[feature].ts
import { LoanSchema } from "@/app/generated/schemas/schemas";
import { z } from "zod";

// 1. Start with generated schema
// 2. Omit auto-generated fields (id, timestamps, foreign keys)
// 3. Transform dates to strings for HTML inputs
// 4. Add custom validation with .refine()
// 5. Use .required() to make optional fields required

const LoanFormFields = LoanSchema.omit({
  id: true,
  createdAt: true,
  updatedAt: true,
  createdByUserId: true,
  borrowerOrgId: true,
  lenderOrgId: true,
});

// Form schema (dates as strings for HTML inputs)
export const CreateLoanFormSchema = LoanFormFields.extend({
  startDate: z.string().min(1, "Start date is required"),
  maturityDate: z.string().min(1, "Maturity date is required"),
}).refine((data) => new Date(data.maturityDate) > new Date(data.startDate), {
  message: "Maturity date must be after start date",
  path: ["maturityDate"],
});

// Server schema (dates coerced for Prisma)
export const CreateLoanSchema = LoanFormFields.extend({
  startDate: z.coerce.date(),
  maturityDate: z.coerce.date(),
}).refine((data) => data.maturityDate > data.startDate, {
  message: "Maturity date must be after start date",
  path: ["maturityDate"],
});

// Export types
export type CreateLoanForm = z.infer<typeof CreateLoanFormSchema>;
export type CreateLoan = z.infer<typeof CreateLoanSchema>;
```

### Prisma Best Practices

#### Schema Design

```prisma
// 1. Use descriptive enum names in SCREAMING_SNAKE_CASE
enum UserRole {
  BORROWER
  LENDER
}

// 2. Add helpful comments for complex fields
model Loan {
  // Use -1 to indicate that the value is N/A
  principalAmount Float

  // Optional fields with ?
  lenderOrgId String?
}

// 3. Use proper relations with explicit names
model Loan {
  borrowerOrgId String
  borrowerOrg   Organization @relation("BorrowerOrganization", fields: [borrowerOrgId], references: [id])

  lenderOrgId   String?
  lenderOrg     Organization? @relation("LenderOrganization", fields: [lenderOrgId], references: [id])
}

// 4. Always include timestamps
createdAt DateTime @default(now())
updatedAt DateTime @updatedAt

// 5. Use cascading deletes appropriately
loan Loan @relation(fields: [loanId], references: [id], onDelete: Cascade)

// 6. Use @db.Text for large text fields
details String @db.Text
```

#### Query Patterns

```tsx
// Select only needed fields
const user = await prisma.user.findUnique({
  where: { id: userId },
  select: {
    id: true,
    name: true,
    email: true,
    avatarUrl: true,
  },
});

// Use include for relations
const loan = await prisma.loan.findUnique({
  where: { id: loanId },
  include: {
    borrowerOrg: true,
    lenderOrg: true,
    kpis: {
      where: { status: "ACCEPTED" },
      orderBy: { createdAt: "desc" },
    },
  },
});

// Batch operations with transactions
await prisma.$transaction([
  prisma.loan.update({ where: { id }, data: { ... } }),
  prisma.auditLog.create({ data: { ... } }),
]);
```

### Enum Handling

```tsx
// 1. Import enums from generated Prisma client
import { UserRole, KpiStatus } from "@/app/generated/prisma/enums";

// 2. Import Zod schemas for enums
import {
  UserRoleSchema,
  KpiStatusSchema,
} from "@/app/generated/schemas/schemas";

// 3. Create label mappings in lib/labels.ts
export const KPI_STATUS_LABELS: Record<KpiStatus, string> = {
  PROPOSED: "Proposed",
  ACCEPTED: "Accepted",
  REJECTED: "Rejected",
};

// 4. Use .options to get enum values for iteration
const KPI_STATUSES = KpiStatusSchema.options;

KPI_STATUSES.map((status) => (
  <SelectItem key={status} value={status}>
    {KPI_STATUS_LABELS[status]}
  </SelectItem>
));
```

### Date Handling

```tsx
// For form inputs (date picker)
function formatDateForInput(date: Date | string | undefined | null): string {
  if (!date) return "";
  const d = new Date(date);
  return d.toISOString().split("T")[0];
}

// Form default values
defaultValues: {
  startDate: formatDateForInput(new Date()),
}

// Display dates with utils
import { formatDate } from "@/lib/utils";
<span>{formatDate(loan.startDate)}</span>
```

### Error Handling

```tsx
// Server Actions: Always return structured errors
try {
  // ... operation
  return { success: true, data: result };
} catch (error) {
  console.error("Descriptive error context:", error);
  return {
    error: error instanceof Error ? error.message : "Generic fallback message",
  };
}

// Client Components: Display errors consistently
{error && (
  <div className="rounded-md bg-destructive/15 p-3 text-sm text-destructive">
    {error}
  </div>
)}

// Validation errors: Let Zod/react-hook-form handle automatically
<FormMessage /> {/* Shows field-specific errors */}
```

---

## üì¶ Third-Party Integrations

### Supabase Storage

```tsx
// lib/supabase.ts - Client configuration
import { createClient } from "@supabase/supabase-js";

export const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY ||
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
  {
    auth: {
      persistSession: false,
      autoRefreshToken: false,
    },
  }
);

// lib/services/storage.ts - Storage operations
export async function uploadFile(
  bucket: string,
  folder: string,
  userId: string,
  file: File
): Promise<string> {
  const fileExt = file.name.split(".").pop() || "jpg";
  const fileName = `${folder}/${userId}-${Date.now()}.${fileExt}`;

  // Convert File to Buffer for server-side upload
  const arrayBuffer = await file.arrayBuffer();
  const buffer = Buffer.from(arrayBuffer);

  const { error } = await supabase.storage
    .from(bucket)
    .upload(fileName, buffer, {
      cacheControl: "3600",
      upsert: true,
      contentType: file.type || "application/octet-stream",
    });

  if (error) {
    console.error("Upload error:", error);
    throw new Error(`Failed to upload: ${error.message}`);
  }

  const {
    data: { publicUrl },
  } = supabase.storage.from(bucket).getPublicUrl(fileName);

  return publicUrl;
}
```

---

## üîê Security Best Practices

### Authentication

```tsx
// Always check session in Server Actions and Server Components
const session = await auth();
if (!session?.user) {
  return { error: "Unauthorized" };
  // or redirect("/auth/signin");
}

// Get full user with relations for authorization
const user = await prisma.user.findUnique({
  where: { id: session.user.id },
  include: { organization: true },
});
```

### Authorization

```tsx
// Role-based access control
if (user.role !== "BORROWER") {
  return { error: "Only borrowers can perform this action" };
}

// Ownership checks
const loan = await prisma.loan.findUnique({
  where: { id: loanId },
});

if (loan.borrowerOrgId !== user.organizationId) {
  return { error: "Access denied" };
}
```

### Input Validation

```tsx
// ALWAYS validate with Zod before database operations
const validated = await Schema.parseAsync(input);

// Validate file uploads
if (!file.type.startsWith("image/")) {
  return { error: "File must be an image" };
}

if (file.size > 2 * 1024 * 1024) {
  return { error: "File size must be less than 2MB" };
}
```

---

## üéØ Code Quality Standards

### TypeScript

```tsx
// Use strict mode (already configured)
// Avoid `any` - use `unknown` or proper types
// Leverage type inference where possible
const [state, setState] = useState<string>(""); // Explicit when needed
const form = useForm<FormType>({ ... }); // Type form data

// Use proper null checks
if (!user?.organization) {
  return null;
}

// Optional chaining and nullish coalescing
const name = user?.name ?? "Unknown";
```

### Imports

```tsx
// Order: React -> Third-party -> Internal (absolute) -> Types
import { useState } from "react";
import { useForm } from "react-hook-form";
import { Button } from "@/components/ui/button";
import { createLoan } from "@/app/actions/loans";
import type { CreateLoanForm } from "@/lib/validations/loan";
```

### Comments

```tsx
// Use JSDoc for complex functions
/**
 * Calculates KPI results based on cloud data
 * @param kpiId - The KPI to calculate
 * @param periodStart - Start of observation period
 * @param periodEnd - End of observation period
 * @returns KPI result with status
 */

// Inline comments for non-obvious logic
// Delete old avatar before uploading new one
if (user?.avatarUrl) {
  await deleteAvatar(user.avatarUrl);
}

// No comments for obvious code
```

### Performance

```tsx
// Memoize expensive computations
const expensiveValue = useMemo(() => calculate(data), [data]);

// Debounce search inputs
const debouncedSearch = useDebounce(searchTerm, 300);

// Lazy load heavy components
const ChartComponent = dynamic(() => import("./chart"), { ssr: false });

// Use Server Components by default
// Only use "use client" when needed (interactivity, hooks, browser APIs)
```

---

## üìù Documentation

### README Updates

- Keep feature lists updated
- Document environment variables
- Include setup instructions for new dependencies

### API Documentation

```tsx
// Document complex Server Actions with JSDoc
/**
 * Invites a lender organization to review a loan
 *
 * @param loanId - ID of the loan to share
 * @param email - Email of the lender user
 * @returns Success status or error message
 *
 * @throws {Error} If loan not found or already has a lender
 */
export async function inviteLender(loanId: string, email: string) {
  // ...
}
```

---

## üöÄ Deployment & Environment

### Environment Variables

```bash
# Database
DIRECT_URL="postgresql://..."

# Auth
NEXTAUTH_SECRET="secret-key"
NEXTAUTH_URL="http://localhost:3000"

# Supabase (optional)
NEXT_PUBLIC_SUPABASE_URL="https://..."
NEXT_PUBLIC_SUPABASE_ANON_KEY="..."
SUPABASE_SERVICE_ROLE_KEY="..." # Server-side operations
```

### Build & Deploy Checklist

1. Run `npm run build` locally to check for errors
2. Run Prisma migrations: `npm run db:migrate`
3. Ensure all env vars are set in production
4. Test Server Actions work in production mode
5. Verify Supabase storage permissions (public bucket policies)

---

## üé® Final Notes

### When Creating New Features

1. ‚úÖ Start with Server Components, add "use client" only if needed
2. ‚úÖ Create Zod schema in `lib/validations/`
3. ‚úÖ Create Server Action in `app/actions/`
4. ‚úÖ Build UI component with shadcn patterns
5. ‚úÖ Add audit logging for important actions
6. ‚úÖ Revalidate affected paths
7. ‚úÖ Test with both roles (borrower/lender)
8. ‚úÖ Ensure responsive design (mobile-first)

### Code Review Checklist

- [ ] Follows design system (colors, spacing, shadows)
- [ ] Has proper error handling and user feedback
- [ ] Validates all inputs with Zod
- [ ] Checks authentication and authorization
- [ ] Uses TypeScript properly (no `any`)
- [ ] Includes loading states for async operations
- [ ] Is responsive and accessible
- [ ] Revalidates paths after mutations
- [ ] Has consistent naming conventions

---

**Remember**: Consistency is key. Follow established patterns, and when in doubt, refer to existing implementations (especially `components/loans/kpi-form-dialog.tsx` and `app/actions/loans.ts` as reference examples).
