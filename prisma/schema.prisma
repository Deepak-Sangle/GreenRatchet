generator client {
  provider = "prisma-client"
  output   = "../app/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

generator zod {
  provider = "prisma-zod-generator"
  config   = "../zod-generator.config.json"
}

enum UserRole {
  BORROWER
  LENDER
}

enum CloudProvider {
  AWS
  GCP
  AZURE
}

enum KPIResultStatus {
  PASSED
  FAILED
  PENDING
}

enum LoanType {
  FIXED_RATE // The interest rate is fixed for the entire loan term
  FLOATING_RATE // The interest rate is variable and changes based on market conditions
  AMORTIZED // The loan is amortized over the loan term
  ANNUITY // The loan is repaid in equal installments over the loan term
  BALLOON // The loan is repaid in a single lump sum at the end of the loan term
  CREDIT_LINE // The loan is a credit line that can be used as needed
  REVOLVING_CREDIT_LINE // The loan is a revolving credit line that can be used as needed
  CREDIT_CARD // The loan is a credit card that can be used as needed
}

model User {
  id             String        @id @default(cuid())
  name           String?
  avatarUrl      String?
  email          String        @unique
  emailVerified  DateTime?
  password       String
  image          String?
  role           UserRole
  organizationId String?
  organization   Organization? @relation(fields: [organizationId], references: [id])
  auditLogs      AuditLog[]
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  loans          Loan[]
}

model Organization {
  id               String            @id @default(cuid())
  name             String
  logoUrl          String?
  // all users in this organization have the same role
  // but they are still have the field `role` in the user table
  type             UserRole
  users            User[]
  borrowerLoans    Loan[]            @relation("BorrowerOrganization")
  lenderLoans      Loan[]            @relation("LenderOrganization")
  cloudConnections CloudConnection[]
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
}

enum LoanCurrency {
  USD
  EUR
  GBP
  JPY
  AUD
  CAD
  CHF
}

enum ObservationPeriod {
  ANNUAL
  QUARTERLY
  MONTHLY
}

model Loan {
  id              String          @id @default(cuid())
  name            String
  currency        LoanCurrency
  // I have no idea what these are, but since our app doesn't handle loan calculations, we are gonna add them
  // Use -1 to indicate that the value is N/A
  // At least one of these three should be set
  principalAmount Float
  committedAmount Float
  drawnAmount     Float
  type            LoanType
  borrowerOrgId   String
  borrowerOrg     Organization    @relation("BorrowerOrganization", fields: [borrowerOrgId], references: [id])
  lenderOrgId     String?
  lenderOrg       Organization?   @relation("LenderOrganization", fields: [lenderOrgId], references: [id])
  startDate       DateTime
  maturityDate    DateTime
  // All the KPIs for this loan
  kpis            KPI[]
  auditLogs       AuditLog[]
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  createdByUserId String
  createdByUser   User            @relation(fields: [createdByUserId], references: [id])
  marginRatchets  MarginRatchet[]
}

enum KpiType {
  CO2_EMISSION
  AI_COMPUTE_HOURS
}

enum KpiValueType {
  ABSOLUTE
  PERCENTAGE
  RATIO
}

enum KpiDirection {
  LOWER_IS_BETTER
  HIGHER_IS_BETTER
}

enum KpiStatus {
  PROPOSED
  ACCEPTED
  REJECTED
}

model MarginRatchet {
  id               String   @id @default(uuid())
  loanId           String
  loan             Loan     @relation(fields: [loanId], references: [id], onDelete: Cascade)
  kpiId            String
  kpi              KPI      @relation(fields: [kpiId], references: [id], onDelete: Cascade)
  // The basis points for margin ratchet; 1 bps = 0.01%
  // step up bps if there is no violation of KPI target
  stepUpBps        Int
  // step down bps if there is violation of KPI target
  stepDownBps      Int
  // Maximum adjustment bps for the margin ratchet
  maxAdjustmentBps Int
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
}

model KPI {
  id             String            @id @default(cuid())
  name           String
  type           KpiType
  valueType      KpiValueType
  direction      KpiDirection
  targetValue    Float
  thresholdMin   Float?
  thresholdMax   Float?
  frequency      ObservationPeriod
  baselineValue  Float?
  status         KpiStatus
  effectiveFrom  DateTime
  effectiveTo    DateTime?
  loanId         String
  loan           Loan              @relation(fields: [loanId], references: [id], onDelete: Cascade)
  results        KPIResult[]
  auditLogs      AuditLog[]
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt
  marginRatchets MarginRatchet[]
}

model KPIResult {
  id          String          @id @default(cuid())
  kpiId       String
  periodStart DateTime
  periodEnd   DateTime
  actualValue Float
  targetValue Float
  status      KPIResultStatus @default(PENDING)
  // Calculation details to be added later
  kpi         KPI             @relation(fields: [kpiId], references: [id], onDelete: Cascade)
  auditLogs   AuditLog[]
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
}

model CloudConnection {
  id                String         @id @default(cuid())
  provider          CloudProvider
  // AWS specific
  roleArn           String?
  externalId        String?
  // GCP specific
  serviceAccountKey String?        @db.Text
  projectId         String?
  // Common
  isActive          Boolean        @default(true)
  lastSync          DateTime?
  organizationId    String
  organization      Organization   @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  auditLogs         AuditLog[]
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt
  cloudServices     CloudService[]
}

model AuditLog {
  id                String           @id @default(cuid())
  action            String // e.g., "KPI_CREATED", "KPI_ACCEPTED", "DATA_PULL", "RESULT_CHANGED"
  entity            String // e.g., "KPI", "LOAN", "CLOUD_CONNECTION"
  entityId          String
  details           String           @db.Text // JSON string
  userId            String?
  user              User?            @relation(fields: [userId], references: [id])
  loanId            String?
  loan              Loan?            @relation(fields: [loanId], references: [id])
  kpiId             String?
  kpi               KPI?             @relation(fields: [kpiId], references: [id])
  kpiResultId       String?
  kpiResult         KPIResult?       @relation(fields: [kpiResultId], references: [id])
  cloudConnectionId String?
  cloudConnection   CloudConnection? @relation(fields: [cloudConnectionId], references: [id])
  createdAt         DateTime         @default(now())
}

// Model for each service (of AWS for now) that is present in the CloudConnection
// Services we currently support are EC2, S3, EBS, RDS, DynamoDB, DocumentDB, Redshift, Neptune, Keyspaces
// additionalData will have info like instance type, storage, etc.
model CloudService {
  id                   String                    @id @default(cuid())
  serviceName          String
  serviceId            String
  region               String // AWS region (e.g., us-east-1, eu-west-1) or "global" for region-agnostic services
  additionalData       Json
  createdAt            DateTime                  @default(now())
  updatedAt            DateTime                  @updatedAt
  cloudUsageDatas      CloudOperationalMetrics[]
  cloudEmbodiedMetrics CloudEmbodiedMetrics[]
  cloudConnectionId    String
  cloudConnection      CloudConnection           @relation(fields: [cloudConnectionId], references: [id])

  @@index([cloudConnectionId, region])
  @@index([serviceName, region])
}

// Model for Cloud Usage Data that we get every hour - this 
// This will have each service's (of AWS for now) usage data  like compute, storage, networking, instance types, etc.
// This traps the operational metrics (scope 2) via cloudwatch to get running co2e per service
model CloudOperationalMetrics {
  id             String       @id @default(cuid())
  // Whose usage data is this? -> CloudService
  cloudServiceId String
  // Need to add correct fields, but I need to know what data i can actually get from the APIs
  cloudService   CloudService @relation(fields: [cloudServiceId], references: [id], onDelete: Cascade)
  periodStart    DateTime // Start of measurement period (typically hourly)
  periodEnd      DateTime // End of measurement period (typically hourly)
  // vCpu hours doesn't make sense since we are calculating this record every hour
  // vCpuHours         Float?
  // This model would only have the analytics like that are present in the `Monitoring` tab of each service
  averageCpuLoad Float? // Services that requires this field for OxygenIT API to work - EC2, 
  network        Float? // Services - EC2, RDS (called exchange), DyanamoDB, DocumentDB, Redshift, Neptune, Keyspaces
  instanceType   String? // Services - EC2
  region         String // Services - all
  storageBytes   Float? // Services - S3, EBS, RDS, DynamoDB, DocumentDB, Redshift, Neptune, Keyspaces
  storageClass   String? // Services - S3
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  @@index([cloudServiceId, periodStart, periodEnd])
  @@map("CloudUsageData")
}

// Model for Embodied Carbon Metrics - calculated monthly from AWS Cost Explorer
// This captures billing cost and usage hours per service/region/instance type
// Used for embodied carbon calculations (scope 3 - manufacturing, shipping, disposal)
model CloudEmbodiedMetrics {
  id                String       @id @default(cuid())
  cloudServiceId    String
  cloudService      CloudService @relation(fields: [cloudServiceId], references: [id], onDelete: Cascade)
  periodStart       DateTime // Start of billing period (typically month start)
  periodEnd         DateTime // End of billing period (typically month end)
  region            String // AWS region (e.g., us-east-1)
  instanceType      String? // EC2/RDS instance type, EBS volume type, etc.
  serviceName       String // EC2, S3, RDS, DynamoDB, DocumentDB, Redshift, Neptune, Keyspaces, EBS
  usageType         String? // Detailed usage type from Cost Explorer (e.g., BoxUsage:t2.micro)
  instanceHours     Float? // Total hours instances were running
  storageGBHours    Float? // Total GB-hours of storage
  requestCount      Float? // Number of requests (for S3, DynamoDB, etc.)
  dataTransferGB    Float? // Data transfer in GB
  totalCost         Float // Total cost in USD for this service/region/type
  unblendedCost     Float? // Unblended cost (without reserved instance discounts)
  additionalMetrics Json? // Flexible field for service-specific metrics
  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt

  @@index([cloudServiceId, periodStart, periodEnd])
  @@index([serviceName, region, periodStart])
}
